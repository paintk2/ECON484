---
title: "Real Estate Analysis"
author: "Group 4"
date: '2022-05-20'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r packages}
library(tidyverse)
library(stringr)
library(fastDummies)
library(glmnet)
library(glue)
```

```{r accesory}
accessory <- read.csv("./data/EXTR_Accessory_V.csv")

accessory <- accessory %>% 
  mutate(mm_key = paste0(Major, '-', Minor), .before = 1) %>% 
  select(-c(Major, Minor, AccyDescr, UpdatedBy, UpdateDate)) %>% 
  mutate(DateValued = substr(DateValued, 1, 4))

accessory <- accessory %>% 
  filter(Size >= 0)

accessory$AccyType <- as.factor(accessory$AccyType)

accessory <- accessory %>% 
  select(mm_key, AccyType, DateValued) %>% 
  group_by(mm_key, DateValued) %>% 
  dummy_cols(select_columns = "AccyType") %>%
  select(-AccyType) %>% 
  group_by(mm_key, DateValued) %>% 
  summarise(across(where(is.numeric), sum))

accessory$DateValued <- as.integer(accessory$DateValued)
```

```{r sales}
# Data Wrangling 
raw_sales <- read.csv("./data/EXTR_RPSale.csv")

#change document date to year/date format 
# remove non-residential buildings
sales_clean <- raw_sales %>% 
  filter(PropertyType %in% c(10, 11, 12, 13, 14, 18, 19, 2, 3, 6)) %>% 
  filter(PrincipalUse == 6) %>% 
  mutate(DocumentDate = as.numeric(substr(DocumentDate, 7, 10)))
  # mutate(DocumentDate = as.Date(DocumentDate, format = c("%m/%d/%Y")))


# sales <- sales_clean %>% 
#   filter(DocumentDate >= "2012-01-01")
sales <- sales_clean %>%
  filter(DocumentDate >= 2012)
  

  # not including mobile homes, check 6 

# Combines Major and Minor columns
combineID <- function(df) {
  df %>% 
    mutate(mm_key = paste0(Major, '-', Minor), .before = 1) %>% 
    select(-c(Major, Minor))
}

sales <- combineID(sales)
# test <- sales %>% filter(str_detect(AFForestLand, 'Y'))

# removing useless information
sales <- sales %>%
  select(c(mm_key, DocumentDate, SalePrice, PropertyType, PrincipalUse, SaleInstrument, AFForestLand, AFCurrentUseLand, AFNonProfitUse, AFHistoricProperty, SaleReason, PropertyClass))
sales$PropertyType <- as.factor(sales$PropertyType)
sales$PrincipalUse <- as.factor(sales$PrincipalUse)
sales$SaleInstrument <- as.factor(sales$SaleInstrument)
sales$SaleReason <- as.factor(sales$SaleReason)
sales$PropertyClass <- as.factor(sales$PropertyClass)

# sales %>% distinct(AFNonProfitUse)
# test <- sales %>% 
#   group_by(mm_key) %>%
#   count()

# replace Y,y,N,n,0,1 and NULL values with binary 0's and 1's
lookup <- c("Y" = 1, "y" = 1, "1" = 1, "N" = 0, "n" = 0, "0" = 0)
sales$AFCurrentUseLand <- lookup[sales$AFCurrentUseLand]
sales$AFCurrentUseLand[is.na(sales$AFCurrentUseLand)] = 0

sales$AFForestLand <- lookup[sales$AFForestLand]
sales$AFForestLand[is.na(sales$AFForestLand)] = 0

sales$AFHistoricProperty <- lookup[sales$AFHistoricProperty]
sales$AFHistoricProperty[is.na(sales$AFHistoricProperty)] = 0

sales$AFNonProfitUse <-lookup[sales$AFNonProfitUse]
sales$AFNonProfitUse[is.na(sales$AFNonProfitUse)] = 0
# 
# nrow(test)
# nrow(sales)

```


```{r residential}
resBldg <- read.csv("./data/EXTR_ResBldg.csv")
resBldg <- combineID(resBldg)

# removing useless
resBldg <- resBldg %>%
  select( -c(Address, BuildingNumber, Fraction, DirectionPrefix, StreetName, StreetType, DirectionSuffix, ))
resBldg$BldgGrade <- as.factor(resBldg$BldgGrade)
resBldg$FinBasementGrade <-
  as.factor(resBldg$FinBasementGrade)
resBldg$DaylightBasement <-
  as.factor(resBldg$DaylightBasement) 
resBldg$HeatSystem <- as.factor(resBldg$HeatSystem)
resBldg$HeatSource <- as.factor(resBldg$HeatSource)
resBldg <- resBldg %>% 
  mutate(DaylightBasement = ifelse(tolower(DaylightBasement) == "y", 1, 0)) %>%
  mutate(ViewUtilization = ifelse(tolower(ViewUtilization) == "y", 1, 0))

str(resBldg)
```



```{r parcel}
parcel <- read.csv("./data/EXTR_Parcel.csv")

parcel_red <- parcel %>% 
  select(-c(PropName, PlatName, PlatLot, SpecArea, SpecSubArea))  #plat lot ?? check 

rm(parcel)

parcel_red$Area <- as.factor(parcel_red$Area)

parcel_red$SubArea <- as.factor(parcel_red$SubArea)

parcel_red$HBUAsIfVacant <- as.factor(parcel_red$HBUAsIfVacant)

parcel_red$HBUAsImproved <- as.factor(parcel_red$HBUAsImproved)

parcel_red[, 18:24] <- lapply(parcel_red[, 18:24], function(y) {as.factor(y)})

parcel_red <- parcel_red %>% 
  mutate(Unbuildable = ifelse(Unbuildable == "True", 1, 0))

parcel_red[, 27:36] <- lapply(parcel_red[, 27:36], function(y) {as.factor(y)}) 

parcel_red[, 39:41] <- lapply(parcel_red[, 39:41], function(y) {as.factor(y)})

parcel_red[, 44:46] <- lapply(parcel_red[, 44:46], function(y) {as.factor(y)})

parcel_red$HistoricSite <- as.factor(parcel_red$HistoricSite)

parcel_red$CurrentUseDesignation <- as.factor(parcel_red$CurrentUseDesignation)

parcel_red[, 42:43] <- lapply(parcel_red[, 42:43], function(y) {if (y == "Y") { y = as.factor(1)} else {y = as.factor(0)}})

parcel_red[, 48:49] <- lapply(parcel_red[, 48:49], function(y) {if (y == "Y") { y = as.factor(1)} else {y = as.factor(0)}})

parcel_red[, 74:75] <- lapply(parcel_red[, 74:75], function(y) {if (y == "Y") { y = as.factor(1)} else {y = as.factor(0)}})

parcel_half <- parcel_red %>% 
  select(NbrBldgSites:OtherProblems)

parcel_red <- parcel_red %>% 
  select(Major:OtherNuisances)

parcel_half[, 3:5] <- lapply(parcel_half[, 3:5], function(y) {if (y == "Y") { y = as.factor(1)} else {y = as.factor(0)}})

parcel_half[, 8:27] <- lapply(parcel_half[, 8:27], function(y) {if (y == "Y") { y = as.factor(1)} else {y = as.factor(0)}})

# rm(ls(parcel_half, parcel_red))

parcel <- cbind(parcel_red, parcel_half)

parcel <- parcel %>% 
  mutate(mm_key = paste0(Major, '-', Minor), .before = 1) %>% 
  select(-c(Major, Minor))
```

```{r}
#Function to Sort Y/N
y = data.frame()
test = function(d,c1,...){
colname = c(c1,...) 
print(colname)
print(length(colname))
for(i in seq_along(colname)){
    x = colname[i]
    print(x)
    print(class(x))
    lookup <- c("Y" = 1, "y" = 1, "1" = 1, "N" = 0, "n" = 0, "0" = 0)
    factor_cols <- c(x)
    d[, factor_cols] = lookup[d[,factor_cols]]
    
    
}
 return(d)
}

```

```{r condo}
#Condo Units Data Set
condo_units = read.csv("data/EXTR_CondoUnit2.csv")

cu_df = data.frame(condo_units)
cleaned_condo_units = cu_df %>%
  mutate(mm_key = paste0(Major, '-', Minor), .before = 1) %>%  #Creating mm_key
  select(-c(Major, Minor)) %>%
  select(-c(BldgNbr, UnitNbr,MHomeDescr,PersPropAcctNbr,Address,BuildingNumber,Fraction,DirectionPrefix,StreetName,DirectionSuffix,UnitDescr,ZipCode)) #Removing Non relevant Vars

#Splitting
chunk <- 10000
n <- nrow(cleaned_condo_units)
r <- rep(1:ceiling(n/chunk), each=chunk)[1:n]
d <- split(cleaned_condo_units, r)

#Applying Factors 
d <- lapply(d, function(x){
  x$UnitType = as.factor(x$UnitType)
  x$UnitQuality = as.factor(x$UnitQuality) 
  x$UnitLoc = as.factor(x$UnitLoc)
  x$UnitOfMeasure = as.factor(x$UnitOfMeasure)
  x$Condition = as.factor(x$Condition)
  x$OtherRoom = as.factor(x$OtherRoom) 
  x$ViewMountain = as.factor(x$ViewMountain)
 x$ViewLakeRiver = as.factor(x$ViewLakeRiver)
 x$ViewCityTerritorial = as.factor(x$ViewCityTerritorial)
 x$ViewPugetSound = as.factor(x$ViewPugetSound)
 x$ViewLakeWaSamm = as.factor(x$ViewLakeWaSamm)
 x$PkgOpen = as.factor(x$PkgOpen)
 x$PkgCarport = as.factor(x$PkgCarport)
 x$PkgBasement = as.factor(x$PkgBasement)
 x$PkgBasementTandem = as.factor(x$PkgBasementTandem)
 x$PkgGarage = as.factor(x$PkgGarage)
 x$PkgGarageTandem = as.factor(x$PkgGarageTandem)
 x$PkgOtherType = as.factor(x$PkgOtherType)
 x$Grade = as.factor(x$Grade)
  return(x)
})

#Merging Data Partitions
cleaned_condo_units = bind_rows(d)
c_units = test(cleaned_condo_units, "TopFloor", "Fireplace","EndUnit")
```




```{r merge}
View(distinct(resBldg, mm_key))
View(distinct(df, AccyType))

final_df <- sales %>%
  filter(SalePrice > 0) %>% 
  left_join(resBldg, by="mm_key") %>%
  group_by(mm_key, DocumentDate) %>%
  filter(DocumentDate >= YrBuilt) %>%
  filter(YrBuilt == max(YrBuilt)) 
  
# test <- final_df %>%
#   left_join(accessory, by="mm_key") %>% 
#   relocate(DateValued, .after = DocumentDate) %>% 
#   mutate(DateValued = ifelse(DateValued == "1900", NA, DateValued)) %>% 
#   group_by(mm_key, DocumentDate) %>%
#   filter(DocumentDate >= DateValued) 
#   
  
#   group_by(mm_kry, DocumentDate) %>% 
#   
#   # left_join(accessory, by="mm_key") %>%
#   # left_join(homeexe, by="mm_key") %>%
# 
#   # left_join(parcel, by="mm_key") %>%
#   # left_join(c_units, by="mm_key")
#   
#   # left_join(valhist, by="mm_key") %>%
#   # left_join(env, by="mm_key") %>%
# resBldg %>%
#   group_by(mm_key) %>% 
#   add_count(mm_key) %>%
#   filter(n()>1)
# 
# test <- df %>% 
#   group_by(mm_key) %>% 
#   add_count(mm_key) %>%
#   filter(n()>1) %>%
#   group_by(YrBuilt) %>% 
#   filter(n()>1)
# 
# write.csv(df, "sales.csv", row.names = FALSE)
```


```{r clean}
# Analyzing how to clean the final data

# chekcing of NA
sapply(final_df, function(x) sum(x == 0))
# No NA, but for example, there are empty cells in Zipcode when I look at them in view
# ZipCode: Character -> keep first 5 numbers and factor

# checking of 0s
sapply(final_df, function(x) sum(x == 0))
# zipcode: 1 
# Building grade variation ?? most of non 0 obs are 99
# SqFt columns: check if their floor count matches
# SqFtTotLiving: 1
# Brickstone?? 0-100
# Do we want to keep Bath 3qtrcount?? or convert them to full count
# PcntComplete: 311765
# Obsolescence??
# PcntNetCondition: mostly 0. Maybe drop b/c Condition column already has information on the condition
# 

unique(final_df$ZipCode)
```


```{r joinAccessory}
# Join sales and accessory

# Selecting cols to easily see the join result
col = c("mm_key", "DocumentDate", "DateValued","AccyType_1","AccyType_2","AccyType_3", "AccyType_6", "AccyType_7","AccyType_8","AccyType_12", "AccyType_13", "AccyType_14","AccyType_15" ,"AccyType_16", "AccyType_17", "AccyType_18","AccyType_19","AccyType_20","AccyType_21","AccyType_22","AccyType_23", "AccyType_24","AccyType_25","AccyType_26","AccyType_27","AccyType_28", "AccyType_29","AccyType_30",        "AccyType_31","AccyType_32","AccyType_33","AccyType_34", "AccyType_35","AccyType_36",  "AccyType_37" , "AccyType_38", "AccyType_39","AccyType_40")

col2 = c("DateValued","AccyType_1","AccyType_2","AccyType_3", "AccyType_6", "AccyType_7","AccyType_8","AccyType_12", "AccyType_13", "AccyType_14","AccyType_15" ,"AccyType_16", "AccyType_17", "AccyType_18","AccyType_19","AccyType_20","AccyType_21","AccyType_22","AccyType_23", "AccyType_24","AccyType_25","AccyType_26","AccyType_27","AccyType_28", "AccyType_29","AccyType_30",        "AccyType_31","AccyType_32","AccyType_33","AccyType_34", "AccyType_35","AccyType_36",  "AccyType_37" , "AccyType_38", "AccyType_39","AccyType_40")

acc_df <- left_join(final_df, accessory)
# acc_df <- acc_df %>%
#   select(col)

# Keep records for houses that either have no record of accessory or accessory's date value was before 
# the sale of the house
# If there is one obs for a mm_key 12345-12345 with sales year 2012 value date 2015, this obs is removed
acc_df2 <- acc_df %>%
  group_by(mm_key, DocumentDate) %>%
  mutate(DateValued = ifelse(DateValued <= DocumentDate, DateValued, NA))%>% 
  distinct()

acc_df2 <- acc_df2 %>%
  mutate(DateValued = ifelse(is.na(DateValued), 0, DateValued))

# If there were multiple changes between sales, only keep the most recent one
acc_df3 <- acc_df2 %>%
  group_by(mm_key, DocumentDate) %>%
  filter((DateValued == max(DateValued) | is.na(DateValued))) %>% 
  distinct()
  
# Check for duplicates
acc_df2 %>%
  group_by(mm_key) %>%
  filter(n() > 1) %>%
  arrange(mm_key)

acc_df3 %>%
  group_by(mm_key) %>%
  filter(n() > 1) %>%
  arrange(mm_key)

acc_df4 <- acc_df3 %>%
  select(-col2)

# Please double check if the number of observations is correct
diff <- setdiff(acc_df4,final_df)
final_df[ !(final_df$mm_key %in% acc_df4$mm_key), ]
```


```{r LASSO}
# LASSO model selection and LASSO regression
# The resulting coefficients will be biased towards 0!

# Store model name, RMSE, and cross validated R2 as dataframe
result <- data.frame(Model=character(),
                 RMSE=double(), 
                 CVR2=double(), 
                 stringsAsFactors=FALSE) 

# Split test and train data
test_index <- sample(1:nrow(acc_df4), as.integer(nrow(acc_df4)*0.2))
train_set <- acc_df3[-test_index,]
test_set <- acc_df3[test_index,]

# Convert to matrix
train_x <- data.matrix(train_set[, names(train_set) != "SalePrice"])
train_y <- train_set$SalePrice

test_x <- data.matrix(test_set[, names(test_set) != "SalePrice"])
test_y <- test_set$SalePrice

# Fit LASSO and predict
lasso.fit <- cv.glmnet(train_x, train_y, family = "gaussian", alpha = 1, k = 5)
pred <- predict(lasso.fit, test_x, s = "lambda.min", type = "response")

# Get test errors and store results
lasso.RMSE <- sqrt(mean((pred - test_set$SalePrice)^2))
lasso.R2 <- lasso.fit$glmnet.fit$dev.ratio[which(lasso.fit$glmnet.fit$lambda == lasso.fit$lambda.min)]

result <- unique(rbind(result, data.frame(Model=c("LASSO + OLS"),
                                          RMSE = c(lasso.RMSE),
                                          CVR2=c(lasso.R2))))

# print coefficients
coef(lasso.fit, s = "lambda.min")
```